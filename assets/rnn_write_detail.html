<figure class="w-page" id="rnn-write-detail">
  {{> assets/rnn_write_detail.svg}}
</figure>
<script>
//
// Data
//
let vectorScale = d3.scaleLinear()
    .domain([0, 1])
    .range([-14, 14]);

let memoryData = [
  {x: 0.4, y: 0.2},
  {x: 0.2, y: 0.2},
  {x: 0.1, y: 0.9},
  {x: 0.9, y: 0.9},
  {x: 0.4, y: 0.3}
];
let interpolationData = [0.5];
let shiftData = [0, 0.2, 0.8];
let previousAttentionData = [0, 0.2, 0, 0.2, 0.6];

//
// DOM
//

let html = d3.selectAll("#rnn-write-detail");
let svg = html.select("svg");
let svgBBox = svg.node().getBoundingClientRect();

let query = svg.selectAll("#query").style("opacity", 0);
let memory = svg.selectAll("#memory use").style("opacity", 0);

//
// Render
//

// Store positions of vectors
function cachePositions(selection) {
  selection.each(function(d) {
    let bBox = this.getBoundingClientRect();
    d.top = bBox.top - svgBBox.top;
    d.left = bBox.left - svgBBox.left;
    d.width = bBox.width;
  });
}

// Render new vector lines
function renderVector(selection) {
  selection
      .attr("transform", (d) => {
        return `translate(${d.left + d.width / 2 - vectorScale(d.x) / 2}, ${d.top + d.width / 2 - vectorScale(d.y) / 2})`
      })
      .attr("x2", (d) => vectorScale(d.x))
      .attr("y2", (d) => vectorScale(d.y))
      .attr("marker-end", "url(#arrowhead)")
      .style("stroke", "grey");
}

// Memory
memory.data(memoryData);
cachePositions(memory);
let memoryVector = svg.selectAll(".memory-vector")
      .data(memoryData)
    .enter().append("line")
      .attr("class", "memory-vector");
renderVector(memoryVector);

let queryData = [{x: 0.7, y: 0.8}];
query.data(queryData);
cachePositions(query);

let queryVector = svg.selectAll(".query-vector")
    .data(queryData)
  .enter().append("line")
    .attr("class", "query-vector");


let clamp = d3.scaleLinear()
    .clamp(true);

function redraw() {

  if (d3.event) {
    let bbox = svg.select("#query").node().getBoundingClientRect();
    let x = d3.event.x - bbox.left - bbox.width / 2;
    let y = d3.event.y - bbox.top - bbox.height / 2;
    //TODO: this clamping is awkward
    queryData[0].x = clamp((x + 25) / 50);
    queryData[0].y = clamp((y + 25) / 50);
  }

  renderVector(queryVector);

  // Dot
  let dotData = memoryData.map(v => 2*(v.x-0.5)*2*(queryData[0].x-0.5)+2*(v.y-0.5)*2*(queryData[0].y-0.5));
  svg.selectAll("#dot use").data(dotData)
    .attr("xlink:href", d => d < 0 ? "#array-negative-value" : "#array-positive-value")
    .style("opacity", d => Math.abs(d));

  // Softmax
  let expDotData = dotData.map(Math.exp);
  let softmaxData = expDotData.map(x => x/d3.sum(expDotData));
  svg.selectAll("#softmax use").data(softmaxData)
    .style("opacity", d => d);

  // Interpolate
  svg.selectAll("#previous use").data(previousAttentionData)
    .style("opacity", d => d);

  svg.selectAll("#interpolate-amount").data(interpolationData)
    .style("opacity", d => d);

  let interpolateData = previousAttentionData.map((d,i) =>
      interpolationData*d + (1-interpolationData)*softmaxData[i]);
  svg.selectAll("#interpolate use").data(interpolateData)
    .style("opacity", d => d);

  // Convolve
  svg.selectAll("#shift use").data(shiftData)
    .style("opacity", d => d);

  let convolveData = dotData.map(x => 0);
  for (var n in shiftData){
    for (var i in convolveData){
      if (i - (1-n) >= 0){
        convolveData[i-(1-n)] += shiftData[n]*interpolateData[i];
      }
    }
  }
  // = dotData;
  svg.selectAll("#convolve use").data(convolveData)
    .style("opacity", d => d);

  // Sharpen
  let sharpenData = convolveData.map(x => x*x);
  sharpenData = sharpenData.map(x => x/d3.sum(sharpenData));
  svg.selectAll("#new-attention use").data(sharpenData)
    .style("opacity", d => d);
}

svg.select("#query-hover").on("mousemove", redraw);
redraw();

</script>