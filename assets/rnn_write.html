<figure class="w-page" id="rnn-write">
  {{> assets/rnn_write.svg}}
</figure>
<script>
(function() {

  function appendArrowhead(selection) {
    selection.append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 5)
        .attr("refY", 0)
        .attr("markerWidth", 10)
        .attr("markerHeight", 10)
        .attr("orient", "auto")
      .append("path")
        .attr("d", "M0,-5L5,0L0,5")
        .style("fill", "none")
        .style("stroke", "grey");
  }

  let vectorScale = d3.scaleLinear()
      .domain([0, 1])
      .range([-14, 14]);

  let memoryData = [
    {x: 0.4, y: 0.2},
    {x: 0.2, y: 0.2},
    {x: 0.1, y: 0.9},
    {x: 0.9, y: 0.9},
    {x: 0.4, y: 0.3},
    {x: 0.1, y: 0.5},
    {x: 0.8, y: 0.8}
  ];

  let writeData = {x: 0.9, y: 0};

  //
  // Read
  //

  let readHtml = d3.selectAll("#rnn-read");
  let svg = readHtml.select("svg");
  let svgBBox = svg.node().getBoundingClientRect();
  let result = svg.select("#read-result").style("opacity", 0);
  let resultBBox = result.node().getBoundingClientRect();
  let memory = svg.selectAll("#memory use");
  let attention = svg.selectAll("#attention use");
  let path = svg.selectAll("#paths path");

  appendArrowhead(svg);
  let resultArrow = svg.append("line")
      .attr("class", "result-line")
      .attr("marker-end", "url(#arrowhead)")
      .style("stroke", "grey");

  memory.data(memoryData)
    .each(function(d) {
      this.style.opacity = 0;
      let bBox = this.getBoundingClientRect();
      d.top = bBox.top - svgBBox.top;
      d.left = bBox.left - svgBBox.left;
      d.width = bBox.width;
    });

  let memoryVectors = svg.selectAll(".vector")
      .data(memoryData)
    .enter().append("line")
      .attr("class", "vector")
      .attr("transform", (d) => {
        return `translate(${d.left + d.width / 2 - vectorScale(d.x) / 2}, ${d.top + d.width / 2 - vectorScale(d.y) / 2})`
      })
      .attr("x2", (d) => vectorScale(d.x))
      .attr("y2", (d) => vectorScale(d.y))
      .attr("marker-end", "url(#arrowhead)")
      .style("stroke", "grey");

  function updateReadAttention(data) {
    attention.data(data)
        .style("opacity", (d) => d + 0.05);

    path.data(data)
        .style("stroke-width", (d) => d * 5 + 0.2);

    let resultX = d3.sum(memoryData, (d, i) => d.x * data[i]) / d3.sum(data);
    let resultY = d3.sum(memoryData, (d, i) => d.y * data[i]) / d3.sum(data);

    resultArrow
        .attr("transform",`translate(${resultBBox.left + resultBBox.width / 2 - svgBBox.left - vectorScale(resultX) / 2}, ${resultBBox.top + resultBBox.width / 2 - svgBBox.top - vectorScale(resultY) / 2})`)
        .attr("x2", (d) => vectorScale(resultX))
        .attr("y2", (d) => vectorScale(resultY));
  }

  let length = memory.size();
  let attentionData = d3.range(length).map(() => Math.random());
  updateReadAttention(attentionData);

  readHtml.on("mousemove", function() {
    let data = [];
    writeAttention.each(function() {
      let bbox = this.getBoundingClientRect()
      let distance = Math.abs(bbox.left - d3.event.x + bbox.width / 2);
      data.push(Math.exp(-distance / 25));
    });
    data = data.map((d) => d / d3.sum(data));
    updateReadAttention(data);
  });

  //
  // Write
  //

  let writeHtml = d3.selectAll("#rnn-write");
  let writeSvg = writeHtml.select("svg");
  let writeMemory = writeSvg.selectAll("#memory use");
  let writeNewMemory = writeSvg.selectAll("#new-memory use");
  let writeAttention = writeSvg.selectAll("#attention use");
  let writePath = writeSvg.selectAll("#paths path");
  let writeSvgBBox = writeSvg.node().getBoundingClientRect();
  let writeResult = writeSvg.select("#write-result").style("opacity", 0);
  let writeResultBBox = writeResult.node().getBoundingClientRect();
  let newMemoryData = memoryData.map(d => { return {}; });

  appendArrowhead(writeSvg);
  let writeArrow = writeSvg.append("line")
      .attr("class", "write-line")
      .attr("marker-end", "url(#arrowhead)")
      .style("stroke", "grey")
      .attr("transform",`translate(${writeResultBBox.left + writeResultBBox.width / 2 - writeSvgBBox.left - vectorScale(writeData.x) / 2}, ${writeResultBBox.top + writeResultBBox.width / 2 - writeSvgBBox.top - vectorScale(writeData.y) / 2})`)
      .attr("x2", vectorScale(writeData.x))
      .attr("y2", vectorScale(writeData.y));

  writeMemory.data(memoryData)
    .each(function(d) {
      this.style.opacity = 0;
      let bBox = this.getBoundingClientRect();
      d.top = bBox.top - writeSvgBBox.top;
      d.left = bBox.left - writeSvgBBox.left;
      d.width = bBox.width;
    });

  let writeMemoryVectors = writeSvg.selectAll(".vector")
      .data(memoryData)
    .enter().append("line")
      .attr("class", "vector")
      .attr("transform", (d) => {
        return `translate(${d.left + d.width / 2 - vectorScale(d.x) / 2}, ${d.top + d.width / 2 - vectorScale(d.y) / 2})`
      })
      .attr("x2", (d) => vectorScale(d.x))
      .attr("y2", (d) => vectorScale(d.y))
      .attr("marker-end", "url(#arrowhead)")
      .style("stroke", "grey");

  writeNewMemory.data(newMemoryData)
    .each(function(d) {
      this.style.opacity = 0;
      let bBox = this.getBoundingClientRect();
      d.top = bBox.top - writeSvgBBox.top;
      d.left = bBox.left - writeSvgBBox.left;
      d.width = bBox.width;
    });

  let writeNewMemoryVectors = writeSvg.selectAll(".new-vector")
      .data(newMemoryData)
    .enter().append("line")
      .attr("class", "new-vector")
      .attr("marker-end", "url(#arrowhead)")
      .style("stroke", "grey");

  function updateWriteAttention(data) {
    newMemoryData.forEach((d, i) => {
      d.x = (memoryData[i].x + writeData.x * data[i]) / (1 + data[i]);
      d.y = (memoryData[i].y + writeData.y * data[i]) / (1 + data[i]);
    });
    writeNewMemoryVectors
        .attr("transform", (d) => {
          return `translate(${d.left + d.width / 2 - vectorScale(d.x) / 2}, ${d.top + d.width / 2 - vectorScale(d.y) / 2})`
        })
        .attr("x2", (d) => vectorScale(d.x))
        .attr("y2", (d) => vectorScale(d.y));

    writeAttention.data(data)
        .style("opacity", (d) => d + 0.05);

    writePath.data(data)
        .style("stroke-width", (d) => d * 5 + 0.2);
  }

  writeHtml.on("mousemove", function() {
    let data = [];
    writeAttention.each(function() {
      let bbox = this.getBoundingClientRect()
      let distance = Math.abs(bbox.left - d3.event.x + bbox.width / 2);
      data.push(Math.exp(-distance / 25));
    });
    data = data.map((d) => d / d3.sum(data));
    updateWriteAttention(data);
  });

})();
</script>